# 简介

布隆过滤器可以理解为一个不太精确的Set结构，它可能会出现误判的情况，且**只可能**将没见过的误判为见过。打个比方，当你觉得对某个知识点不太了解时，那你肯定不熟；但当你觉得对某知识点很熟悉的时候，有可能是你的误判。由于这一特性，布隆过滤器可以应用在新闻、短视频等内容推荐系统中，可以保证推荐给用户的都是用户没看过的。弊端就是可能会将用户没看过的内容也给过滤了，用户就可能错过一些推荐(不过只是极少一部分)。



# 原理的简单解释

不同于Java中的HashSet，每个布隆过滤器对应到 Redis 的数据结构里面就是一个大型的「**位数组**」和**几个**不一样的「**无偏 hash 函数**」。“无偏”就是能够把元素的 hash 值算得比较均匀。过程如下图所示：

![布隆过滤器-图一](\images\posts\Redis\布隆过滤器-图一.jpg)

基于这一过程，就可以解释布隆过滤器为什么会出现“选择性”误判这一情况了：

- 没见过的就是没见过：通过几个无偏hash函数对key进行计算后，只要有一个位置为0，就说明肯定不存在；
- “见过”的不一定真的见过：key的计算结果中，每个位置都是1的话，只代表极有可能存在，但并不是真的存在(因为见过了key1、key2，误认为key3也见过了)。具体可见下图：

![布隆过滤器-图二](\images\posts\Redis\布隆过滤器-图二.jpg)

从这里，仅凭直觉可以得出**位数组**比较稀疏的时候(即1的占比比较小)判断正确的概率就会很大，当“见过”的元素越来越多的时候，**位数组**就会变得比较拥挤，这个时候误判的概率就会比较大。Redis提供了自定义参数的布隆过滤器，在使用add之前，使用reserve指令可以自定义布隆过滤器，该指令需要指定三个参数：

- **name**: 布隆过滤器的名称
- **error_rate**：期望错误率，由上述分析可知，期望错误率越低，所需的空间越多
- **initial_size**: 表示预计放入的元素数量，当实际数量超出这个数值时，由于位数组变得拥挤，误判率会上升。

# 布隆过滤器的应用

## 预防缓存穿透

**缓存穿透**

「**缓存穿透**」是指用户请求的数据既没命中缓存，在数据库中也不存在，导致每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。

**解决方案**

这个时候就可以使用布隆过滤器，这样就能阻挡大部分不存在的数据，仅有极少部分由于误判而通过过滤器，而不会阻拦任何一个存在的信息，从而避免了对底层存储系统的查询压力。

## 垃圾邮件分拣

平常可能出现正常邮件被放入了垃圾邮件的目录中这一情况，这个就很有可能是由于邮件系统采用了布隆过滤器，而产生了误判导致的。