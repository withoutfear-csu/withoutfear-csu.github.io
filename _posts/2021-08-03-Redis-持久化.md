---
layout: post
title: Redis的持久化
categories: Redis
description: 本文主要介绍了Redis的持久化
keywords: Redis, 持久化
---

本文主要参考《Redis深度历险》，Redis 的持久化机制能够保证 Redis 的数据不会因为故障而丢失，Redis的持久化机制有两种：⼀、快照； ⼆、AOF⽇志。



## 概述

 	Redis 的持久化机制能够保证 Redis 的数据不会因为故障而丢失，Redis的持久化机制有两种：⼀、快照； ⼆、AOF⽇志。

## 快照(RDB)

 	快照是⼀次**全量备份**，是内存数据的⼆进制序列化形式，在存储上非常**紧凑**。 

### 问题

​	实现持久化要求 Redis ⼀边进行文件 IO 操作，⼀边响应客户端请求。但⽂件IO操作不能使用多路复用 API，且Redis是单线程程序。由此引出以下两个问题： 

- Redis是如何做到在不阻塞业务的前提下进行持久化的呢？ 

- 持久化的同时，由于要处理业务，内存数据结构是在改变的。在持久化过程中数据被删除了怎么办？

### 实现原理

​	Redis 使用了操作系统的多进程 **COW(Copy On Write)** 机制来实现快照持久化。(并且在子进程存在期间，服务器会提高负载因子的阈值，从而避免在子进程存在期间进行哈希表扩展(**rehash**)操作，避免不必要的内存写⼊操作，最大限度地节约内存) 

#### COW的介绍 

**COW的定义**

> 写⼊时复制 (英语：Copy-on-write，简称COW）是⼀种计算机程序设计领域的优化策略。其核⼼思想 是，如果有多个调⽤者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取 相同的指针指向相同的资源，直到某个调⽤者试图修改资源的内容时，系统才会真正复制⼀份专⽤副本（private copy）给该调⽤者，而其他调⽤者所⻅到的最初的资源仍然保持不变。这过程对其他的调⽤者 都是透明的。此作法主要的优点是如果调⽤者没有修改该资源，就不会有副本（private copy）被创建， 因此多个调⽤者只是读取操作时可以共享同⼀份资源。



**COW的实现原理**

> fork()之后，kernel把父进程中所有的内存⻚的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安⽆事。当其中某个进程写内存时，CPU硬件检测到内存⻚是read-only的，于是触发页异常中断（page-fault），陷入kernel的⼀个中断例程。中断例程中，kernel就会把 触发的异常的页复制⼀份，于是父子进程各自持有独立的⼀份。

（fork用于创建子进程，fork 函数会在父子进程同时返回，在父进程⾥返回子进程的 pid，在⼦进程里返回零，从而执行不同的代码。如果操作系统内存资源不足，pid 就会是负数，表示 fork 失败）



**小结⼀下**

-  fork()出的子进程刚刚产⽣时，代码段、数据段、堆栈都是指向父进程的物理空间。换句话说，子进程和 父进程共享内存里面的代码段和数据段。由于与父进程共享内存空间，所以创建进程的速度很快。 

- 当父子进程有内存写⼊操作时read-only内存页发⽣中断，将触发的异常的内存页复制⼀份，其他的数据 页还是共享的。



**COW的优缺点**

- **优点**： COW技术可减少分配和复制⼤量资源时带来的瞬间延时。

- **缺点**： 如果在fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断 page-fault)



#### COW在Redis中的应用

> 从COW的实现原理分析出优缺点后，再回来看Redis的持久化，会发现COW这项技术在这能充分发挥它的优势。

Redis在持久化的时候调⽤glibc的 fork() 函数产⽣⼀个⼦进程。**快照持久化**完全交给**子进程**来处理，**父进程**继续处理**客户端请求**。

- 子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进⾏遍历读取，然后序列化 写到磁盘中。因为数据没有变化，它能看到的内存里的数据在进程产⽣的⼀瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫**「快照」**的原因。
- 父进程由于要处理客户端请求，所以会持续修改内存数据结构，越来越多的共享数据页会被复制出来， 但最终不会超过原有数据的2倍。另外⼀个Redis实例中冷数据占的比例往往是比较高的，所以仅有部分 数据页被分离出来。



至此，之前的疑惑就都解决了！

- 由于有父子进程的存在，所以能做到在不阻塞业务的前提下，进行持久化。 

- 由于有COW技术，所以子进程看到的内存数据停留在被创建出来的那⼀瞬间。



## AOF日志

​	AOF 日志是连续的增量备份，记录的是修改内存数据的**指令记录**。AOF ⽇志在长期的运行过程中会变的无比庞⼤，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫⻓。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。

> Redis 提供了 bgrewriteaof 指令⽤于对 AOF ⽇志进⾏瘦身。其原理就是开辟⼀个⼦进程对内存进⾏遍 历转换成⼀系列 Redis 的操作指令，序列化到⼀个新的 AOF ⽇志⽂件中。序列化完毕后再将操作期间 发⽣的增量 AOF ⽇志追加到这个新的 AOF ⽇志⽂件中，追加完毕后就⽴即替代旧的 AOF ⽇志⽂件 了，瘦身⼯作就完成了

### 问题 

​	写AOF⽇志时，实际上是现将内容写⼊为⽂件描述符分配的⼀个内存缓存中，之后由内核将数据刷回到磁盘上。这意味着如果机器突然宕机，数据还未来得及刷⼊磁盘就会使得AOF日志丢失。

### fsync

> Linux 的 glibc 提供了 fsync(int fd)函数可以将指定⽂件的内容强制从内核缓存刷到磁盘，fsync 是⼀个 磁盘 IO 操作。

​	只要Redis实时调⽤fsync，就能够保障AOF日志不丢失，但由于fsync是磁盘IO操作，这样以来就要牺牲 redis的性能，因此有以下⼏种策略：

- 每隔 ⼀个周期执行⼀次 fsync 操作（折中方案，⽣产环境中常用）

- 永不调⽤fsync（AOF日志易丢失）

- 每有⼀个指令，就调用一次fsync（牺牲性能较多）

## 运维

​	从上面的介绍中了解Redis的持久化是⼀个耗时的操作，需要涉及遍历整个缓存、⼤块写磁盘以及fsync这 样的耗时操作。所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是 备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。

> 但是如果出现⽹络分区，从节点长期连不上主节点，就会出现数据不⼀致的问题，特别是在网络分区出 现的情况下⼜不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实时监控⼯作，保证网络畅通或者能快速修复。另外还应该再增加⼀个从节点以降低网络分区的概率，只要有⼀个从节点数据 同步正常，数据也就不会轻易丢失。

## Redis4.0 混合持久化

​	重启Redis使⽤RDB重启会丢失很多数据，使⽤全量AOF⽇志重放则需要花费很多的时间。4.0之后Redis将 .rdb ⽂件的内容和增量的 AOF ⽇志⽂件存在⼀起。Redis 重启的时候，可以先加载 .rdb 的内容，然后再重 放增量 AOF ⽇志就可以完全替代之前的 AOF 全量⽂件重放，重启效率因此⼤幅得到提升。

> **增量的 AOF ⽇志⽂件**
>
> ⾃持久化开始到持久化结束的这段时间⽣成的 AOF 日志，通常这部分 AOF 日志很小。

