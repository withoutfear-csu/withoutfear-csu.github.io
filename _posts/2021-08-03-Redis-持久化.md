# 概述

​	Redis 的持久化机制能够保证 Redis 的数据不会因为故障而丢失，Redis的持久化机制有两种：一、快照；二、AOF日志。



# 快照(RDB)

​	快照(RDB: Redis DataBase) 是一次**全量备份**，是内存数据的二进制序列化形式，在存储上非常**紧凑**。



## 问题

​	实现持久化要求 Redis 一边进行文件 IO 操作，一边响应客户端请求。但文件IO操作不能使用多路复用API，且Redis是单线程程序。由此引出以下两个问题：

- Redis是如何做到在不阻塞业务的前提下进行持久化的呢？
- 持久化的同时，由于要处理业务，内存数据结构是在改变的。在持久化过程中数据被删除了怎么办？



## 实现原理

​	Redis 使用了操作系统的多进程 **COW(Copy On Write)** 机制来实现快照持久化。(并且在子进程存在期间，服务器会提高负载因子的阈值，从而避免在子进程存在期间进行哈希表扩展(**rehash**)操作，避免不必要的内存写入操作，最大限度地节约内存)



### COW的介绍

**COW的定义**

> 写入时复制 (英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。 



**COW的实现原理**

> fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会**把触发的异常的页复制一份**，于是父子进程各自持有独立的一份。

（fork用于**创建子进程**，fork 函数会在父子进程同时返回，在父进程里返回子进程的 pid，在子进程里返回零，从而执行不同的代码。如果操作系统内存资源不足，pid 就会是负数，表示 fork 失败）



**小结一下**

- fork()出的子进程刚刚产生时，代码段、数据段、堆栈都是指向父进程的物理空间。换句话说，子进程和父进程共享内存里面的代码段和数据段。由于与父进程共享内存空间，所以创建进程的速度很快。

- 当父子进程有内存写入操作时read-only内存页发生中断，**将触发的异常的内存页复制一份**，其他的数据页还是共享的。



**COW的优缺点**

**优点：**

- COW技术可**减少**分配和复制大量资源时带来的**瞬间延时**。

**缺点：**

- 如果在fork()之后，父子进程都还需要继续进行写操作，**那么会产生大量的分页错误(页异常中断page-fault)**



### COW在Redis中的应用

> **从COW的实现原理分析出优缺点后，再回来看Redis的持久化，会发现COW这项技术在这能充分发挥它的优势。**

Redis在持久化的时候调用glibc的 fork() 函数产生一个子进程。**快照持久化**完全交给**子进程**来处理，**父进程**继续处理**客户端请求**。

- 子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「**快照**」的原因。

- 父进程由于要处理客户端请求，所以会持续修改内存数据结构，越来越多的共享数据页会被复制出来，但最终不会超过原有数据的2倍。另外一个Redis实例中冷数据占的比例往往是比较高的，所以仅有部分数据页被分离出来。



至此，之前的疑惑就都解决了！

- 由于有父子进程的存在，所以能做到在不阻塞业务的前提下，进行持久化。
- 由于有COW技术，所以子进程看到的内存数据停留在被创建出来的那一瞬间。



## 多久做一次快照

不能频繁执行bgsave：

- 虽然子进程本身不会阻塞主进程，但是fork会阻塞主进程；
- 磁盘带宽有限，频繁写入全量数据，前一个快照还没完成，后一个快照又开始了，容易恶性循环。

### 增量快照

​	所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。但是增量快照并不是完美的，每记录一条修改记录，就需要有用于标识的元数据信息，当要记录的修改很多时，额外空间的开销就会很大。比如一个键值对可能很小只占32个字节，而标识修改的元数据信息就可能需要8个字节。



# AOF日志

​	AOF(Append Only File) 日志是连续的增量备份，记录的是**修改**内存数据的**指令记录**。AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。

## 写后日志

​	不同于数据库的**写前日志**(Write Ahead Log, **WAL**)，AOF日志属于**写后日志**，即在数据写入内存后，才记录日志。

**后写的原因**

- AOF记录的是Redis收到的指令，为了避免额外的检查，在写入日志前并不会对指令进行检查，若采用先写日志就有记录了错误指令的风险
- 由于是命令执行后才写日志，所以不会阻塞当前的写操作

**后写的隐患**

- Redis执行完一个命令，还没来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。(如果拿Redis作缓存的话，还是能够从数据库中恢复的)
- 后写虽然不会阻塞当前指令，但是可能会阻塞后面的操作

## 日志丢失

​	写AOF日志时，实际上是现将内容写入为文件描述符分配的一个内存缓存中，之后由内核将数据刷回到磁盘上。这意味着如果机器突然宕机，数据还未来得及刷入磁盘就会使得AOF日志丢失。

### fsync

> Linux 的 glibc 提供了 fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘，fsync 是一个磁盘 IO 操作。

​	只要Redis实时调用fsync，就能够保障AOF日志不丢失，但由于fsync是磁盘IO操作，这样以来就要牺牲redis的性能，因此有以下几种策略：

- 每隔 一个周期 执行一次 fsync 操作（折中方案，生产环境中常用）
- 永不调用fsync，由操作系统控制（AOF日志易丢失）
- 每有一个指令，就调用一次fsync（牺牲性能较多）

​	综上，**避免主线程阻塞**和**减少数据丢失**无法做到两全其美，只能权衡利弊，做取舍。



## 日志瘦身

**日志过大会带来以下三点问题**

- 文件系统本身对文件大小有限制，无法保存过大的文件；
- 当文件过大的时候，追加记录的效率会降低；
- 当Redis宕机后，若AOF日志过大，则恢复过程会很缓慢。



**瘦身的方法**

  Redis 提供了 **bgrewriteaof** 指令用于对 AOF 日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

![日志瘦身](\images\posts\Redis\日志瘦身.jpg)

> **疑问**
>
> ​	这里为什么AOF缓冲和AOF重写缓冲是两个区域。



# 运维

  从上面的介绍中了解Redis的持久化是一个耗时的操作，需要涉及遍历整个缓存、大块写磁盘以及fsync这样的耗时操作。所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。

> 但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。

# Redis4.0 混合持久化

  重启Redis使用RDB重启会丢失很多数据，使用全量AOF日志重放则需要花费很多的时间。4.0之后Redis将 .rdb 文件的内容和增量的 AOF 日志文件存在一起。Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。