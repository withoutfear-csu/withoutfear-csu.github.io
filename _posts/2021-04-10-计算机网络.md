---
layout: post
title: 计算机网络复习整理
categories: Computer NetWork
description: 总复习
keywords: Computer NetWork, 计算机网络
---

# TCP

## TCP通信流程

![image-20201130140027772](/images/posts/computer network/三次握手-四次挥手.png)

`Tips`:

- 最后的 ack=v+1 是错误的， 改为ack=w+1
- 在第三次握手时，就可以携带数据了

## 常考面试题

- **第三次握手失败**（这里网上的说法有争议）

  - 说法一：服务器一般会重试（再次发送SYN+ACK给客户端），超过一定次数后发送RST包

  - 说法二：立刻发送RST包（为了防止SYN洪泛攻击）

    `tips`：SYN洪泛攻击即利用TCP协议缺陷，通过发送大量的半连接请求（不发生ACK包），耗费CPU和内存资源。

    原始的SYN Flood防护方法：

    - 缩短SYN Timeout时间， 仅在对方攻击频率不高时有效。
    - 设置SYN Cookie， 依赖于对方使用真实IP
    
    

- **为什么是三次握手不是两次**

  - 防止已失效的连接请求到达服务器建立连接浪费资源。（如果是两次的话可能出现如下情况：客户端第一次发送的SYN包没有到达服务器，超时后重发，与服务器建立正常连接，数据传输结束关闭连接后。这时第一次发送得SYN包又突然到达了服务器，服务器开放了资源，但客户端并没有与之连接，这时资源便浪费了）
  - 为了建立可靠的通信，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。简单来说就像打电话一样。
    - ①A给B打电话，为确保设备正常，A说：我是A，能听得到吗？
    - ②B听到了A的声音，但不知道A能不能听到自己的声音，于是B说：能听得到，你呢？
    - ③A听到了B的声音，给B答复：能听得见，我们开始说正事吧！

  

- **建立了连接，但是客户端突然出现故障了怎么办**

  - TCP还设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时。若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接

  

- **为什么客户端最后还要等待2MSL**

  - 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。
  - 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
  - 

- **为什么建立连接是三次握手，关闭连接确是四次挥手呢**

  对比三次握手和四次握手可以发现：
  
  - 三次握手时，服务端直接发送SYN和ACK报文
  - 四次挥手时，服务端先发送ACK报文进行确认，经过CLOSE_WAIT阶段后，再返回FIN报文
  
  原因：因为在客户端申请断开连接的时候，服务器可能还有必要的数据需要发送，不能立即断开连接，所以先返回一个确认，经过CLOSE_WAIT阶段后再断开连接。
  
  


- **TCP四元组**是什么

  两个IP地址和两个端口号。更准确地说，一个TCP连接是由一对端点（套接字）构成

  

- **那为什么它们的seq需要不同的seq呢，我可以直接在seq上加个1，把收到的seq置为相同的不久行了吗，为什么我服务器端要单独发送自己的seq呢**

  - TCP的脆弱性，选择合适的四元组和序列号，任何人都能够伪造一个TCP报文段，从而打断TCP的正常连接，其中一种预防方法就是使得初始化序列号难以被猜出（另一种方法就是加密）。PS: (同一连接可能有多个实例，应该防止出现与其他连接的序列号重叠的情况)														（这种解释不一定对）
  - 使得旧的重复请求的任何组合，都不能够让协议失败！！！（我认为这个肯定对）

  

  ![image-20201209201911046](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201209201911046.png)

  

- 



## TCP与UDP的区别

TCP: 面向连接，可靠，时延大，适用于大文件

UDP: 无连接， 不可靠， 时延小， 适用于小文件



UDP的主要特点

- 无连接，减少开销和发送数据的时延
- 使用最大努力交付，即不保证可靠交付
- 面向报文的，适合一次性传输少量数据的网络应用
- 无拥塞控制，适合很多实时应用
- UDP首部开销小 （仅8个字节）





TCP的主要特点

URG: 发送方的紧急处理

PSH: 接收方的紧急处理



![image-20201218221438284](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201218221438284.png)

#   



# DNS

## 简介

- 域名系统(Domain Name System),用于把便于人们记忆的机器名字转换为IP地址。（主机能够由主机名标识，靠的就是DNS）
- DNS被设计成一个联机分布式系统，并采用**客户/服务器方式**
  - DNS使大多数名字都在本地进行解析，仅少量需要在互联网上通信
  - 因为是分布式系统，所以即时单个计算机出现了故障，也不会妨碍DNS的正常运行
- 采用层次树状结构的命名方法
- DNS采用的运输层协议是UDP，使用53号端口

![image-20201208122540940](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201208122540940.png)

`Tips`: 中央电视台电子邮箱的域名：**mail.cctv.com**

**DNS是：**

- ① 一个由分层的DNS服务器实现的分布式数据库；
- ② 一个使得主机能够查询分布式数据库的应用层协议
- ③ 一个不直接与用户打交道的应用



>  **DNS除了进行主机名到IP地址的转换之外，还提供了一些重要服务**

- 主机别名
- 邮件服务器别名
- 负载分配
  - 繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。因此，存在一个IP地址集合能够与同一个**规范主机名**相联系的现象。
  - 当客户对上述**规范主机名**发出DNS请求时，该服务器会响应一个IP地址的集合，但在每次回答中循环这些地址的次序，以达到为所有冗余Web服务器循环分配负载的效果。

> 若采用集中式设计的问题

- 单点故障
- 通信容量
- 距离过远
- 维护困难



## DNS 服务器

## DNS服务器的类型

- 根DNS服务器
- 顶级域（TLD）DNS服务器    负责顶级域名
- 权威DNS服务器

![image-20201211170934424](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201211170934424.png)



---

> **本地DNS服务器**

​		一个本地DNS服务器严格来说并不属于该服务器的层次结构，但它对DNS层次结构是重要的。

- 每个ISP（互联网服务提供商）都有一台本地的DNS服务器（也叫默认名字服务器）
- 当主机（**A**）与ISP连接时，该ISP提供一台主机（**B**）的IP地址，该主机（**B**）具有 一台或多台其本地DNS服务器 的IP地址（通常通过DHCP）。
- 主机（B）的本地DNS服务器通常 “邻近” 本主机



`Tips` **DHCP**：建立于UDP协议上的应用层协议





## DNS的请求过程

> **DNS缓存**

- 目的
  - 为了改善时延性能
  - 减少因特网上到处传播的DNS报文数量
- 原理
  - 当某DNS服务器接收到一个DNS回答时，它能将该回答中的信息缓存在本地存储器中。
  - 当有查询到达该服务器时，若查询的主机名在本地缓存中存在，则该服务器能够直接提供IP地址
  - 由于主机和主机名与IP地址间的映射不是永久的，DNS服务器在一段时间后（通常为两天）将丢弃缓存信息



> **没有DNS缓存的时候**

**描述**：**主机cis.poly.edu** 想知道 **主机gaia.cs.umass.edu** 的IP地址

![image-20201211193629588](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201211193629588.png)







## DNS安全性

- 分布式拒绝服务(**DDoS**)带宽洪泛攻击

​		某攻击者试图向每个DNS**根务器**发送大量的分组，使得大多数合法的DNS请求得不到回答。（但许多DNS根服务器收到了分组过滤器的保护，此外，大多数本地DNS服务器缓存了顶级域名服务器的IP地址，使得这些请求过程通常绕过了DNS根服务器）

​		潜在更为有效的DDoS攻击方式是向**顶级域名服务器**发送大量的DNS请求。（顶级服务器不像跟服务器那样容易绕过，且DNS请求的过滤也更加困难，但这种攻击的严重性还是会被DNS服务器中的本地缓存技术部分地缓解。）



`Tips:` DoS——拒绝服务攻击



- 中间人攻击

​		攻击者截获来自主机的请求，并返回伪造的回答。



- DNS毒害攻击

​		攻击者向一台DNS服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录。



`Tips:`  中间人攻击 和 DNS毒害攻击 难以实现，因为要求它们截获分组或遏制住服务器。



- 利用DNS的反射攻击(取得了有限的成功)



#  







# HTTP1.0、HTTP1.1 和 HTTP2.0 

## Http1.0

​	不支持长连接，每次请求都需要TCP三次握手和四次挥手，和服务器重新建立连接。

## HTTP1.1

​	支持持久连接(keep-alive)，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。







## HTTP状态码

> 分类

| 分类 | 描述                                           |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |



> 详细说明

| 状态码 |        状态码英文名称         |                           中文描述                           |
| :----: | :---------------------------: | :----------------------------------------------------------: |
|  201   |            Created            |                已创建，成功请求并创建了新资源                |
|  202   |           Accepted            |              已接受。已经接受请求，但未处理完成              |
|  203   | Non-Authoritative Information |                          未授权信息                          |
|  204   |          No Content           |                            无内容                            |
|  205   |         Reset Content         |                           重置内容                           |
|  206   |        Partial Content        |                           部分内容                           |
|  301   |       Move Permanently        |                           永久移动                           |
|  302   |             Found             |                           临时移动                           |
|  303   |           See Other           |                    查看其他地址(GET POST)                    |
|  304   |         Not Modified          |                            未修改                            |
|  305   |           Use Proxy           |                           使用代理                           |
|  307   |      Temporary Redirect       |                临时重定向(使用GET请求重定向)                 |
|  400   |          Bad Request          |              客户端请求语法错误，服务端无法理解              |
|  401   |         Unauthorized          |                      请求要求用户的身份                      |
|  403   |           Forbidden           |             服务器理解请求用户的请求，但拒绝执行             |
|  405   |      Method Not Allowed       |                   客户端请求中的方法被禁止                   |
|  406   |        Not Acceptable         |          服务器无法根据客户端请求的内容特性完成请求          |
|  407   | Proxy Authentication Required | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
|  408   |       Request Time-out        |           服务器等待客户端发送的请求时间过长，超时           |
|  410   |             Gone              | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
|  501   |        Not Implemented        |             服务器不支持请求的功能，无法完成请求             |
|  502   |          Bad Gateway          | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
|  503   |      Service Unavailable      |    由于超载或系统维护，服务器暂时的无法处理客户端的请求。    |
|  504   |       Gateway Time-out        |      充当网关或代理的服务器，未及时从远端服务器获取请求      |
|  505   |  HTTP Version not supported   |        服务器不支持请求的HTTP协议的版本，无法完成处理        |



#   





# HTTPS

## 简介

​	基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护，非明文传输。

> 特点

- 通信使用密文
- 和服务端使用相同的算法，根据网络请求参数生成一个token，请求/应答时根据token来确定双方的身份
- 有完整性验证

```txt
Https = Http + 加密 + 认证 + 完整性验证

Https = Http + SSL(位于应用层与传输层之间的协议)
```

![image-20201207184510999](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201207184510999.png)

## SSL协议过程图解(基于RSA算法)

![image-20201207192558710](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201207192558710.png)

## SSL的加密方式

- 对称加密
  - 加密和解密使用同样的密钥
  - 如果通信被窃听，密钥被窃取，那么加密就没有了意义
- 非对称加密
  - 公钥加密，私钥解密
  - 需要大量计算，效率太低
- 混合加密：既使用对称加密，也使用了非对称加密

> **SSL 从安全和效率方面进行考量，选择了混合加密的方式**

- 非对称加密在SSL中的应用

  公钥加密，私钥解密来传输生成密钥的种子(Pre-master secret)

- 对称加密在SSL中的应用

  SSL9次握手之后双方都使用master secret对通信数据进行加密



## 如何验证证书

- 客户端计算明文信息(INFO)的摘要hash
- 使用CA证书的公钥解密签名（客户端内置CA证书）对比证书的信息摘要，若一致，则证书合法



`Tips:` 证书=公钥+申请者与颁发者信息+签名

## HTTPS并非绝对安全

> **中间人攻击**（也是抓包工具的原理）

![image-20201207195648472](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201207195648472.png)

## 如何避免抓包

> 仅简单给出概念

- 使用自定义协议；
- 使用SSL Pinning;



#   



# 在浏览器中输入URL后发生了什么

![image-20201211155727180](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201211155727180.png)

用户的主机请求URL www.someschool.edu/index.html 后

- 为了使**用户**的主机能够将一个HTTP请求报文，发送给Web服务器www.someschool.edu， 必须先获得它的IP地址
  - 抽出主机名，传给DNS应用的客户端(调用gethostbyname()函数)
  - DNS客户向DNS服务器发送一个包含主机名的请求
  - DNS客户最终收到一份回答报文，其中含有对应于该主机的IP地址
  - 一旦浏览器接收到来自DNS的该IP地址，它就能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接
- 

















#   

#     

#    

#   

#   









# 计网快速回顾

## OSI 与 TCP/IP参考模型

![image-20201206122324910](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201206122324910.png)



- TCP/IP参考模型没有区分服务、接口和协议。
- OSI模型和协议过于复杂，实现笨拙 效率慢





## 面向攻击的网络

DoS——拒绝服务攻击， DoS攻击的三大类型

- 弱点攻击
  - 
- 带宽洪泛
  - 攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入连路变得拥塞，使得合法的分组无法到达服务器。
- 连接洪泛
  - a



## 应用层协议

- HTTP
- HTTPS
- FTP
- POP3
- SMTP
- DNS
- DHCP

## 传输层协议





## 传输层

从传输层的角度来看，通信的**真正端点**，并**不是主机**，**而是**主机中的**进程**。也就是说，端到端的通信是**应用进程之间的通信**。

与**网络层**提供**主机间**的逻辑通信不同，**传输层**提供**应用进程间**的逻辑通信。

传输层会对收到的报文进行差错检测。

> **复用与分用**

**复用**：指**发送方** **所有** 应用进程（加上适当的首部后）都可以通过同一个传输层协议传输数据。

**分用**：是指**接收方**的运输层在剥去报文的首部后能够把这些数据正确交付给进程。

> **端口**(逻辑端口)

- 一种抽象的**软件**结构，包括一些数据结构和I/O缓冲区

- 应用程序（即进程）通过系统调用与某端口建立连接(binding绑定)后，传输层传给该端口的数据都被相应的进程所接收，相应进程发给传输层的数据都从该端口输出

> **端口号**

- 16位的标志符，标识传输层协议和应用程序之间的数据接口，端口号是由不同的主机上的TCP和UDP协议独立分配的。
- 端口号只有本地意义

> **套接字**

- **IP地址** + **端口号**，唯一标识一端。在TCP协议中，一条连接两端的套接字就可以唯一标识该连接了。

  `Tips`: IP地址标识主机，端口号标识主机上的进程

> **套接字 —— 端口的基本分配方式**

![image-20210311152423965](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210311152423965.png)

- 知名端口号well-known port numbers（0－1023）
  - 互联网名称与数字地址分配机构（ICANN）预留给传输控制协议（TCP）和 用户数据包协议（UDP）使用的端口号
    - 远程任务入口应用程序使用端口号5
    - 超文本传输协议（HTTP）应 用使用端口号80
    - 邮局协议（POP3）使用端口号110
- 注册端口号registered port numbers（1024－49151）
  - 公司和其他用户向互联网名称与数字地址分配机构（ICANN）登记的端 口号。
    - Sun公司的NEO Object Request Broker（端口号1047和1048） 和Shockwave（端口号1626）
- 动态端口号或私有端口号（49152－65535）
  - 进程需要访问传输层服务时，向本地操作系统提出申请，返回本地唯一的端 口号，进程再通过合适的系统调用，将自己和该端口连接起来。

![image-20201209142858512](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20201209142858512.png)

### TCP 

> **功能概述**

​	TCP弥补了IP协议不可靠的特性，向应用层提供可靠的 **面向连接** 的服务，实现了通信进程的连接与释放、滑动窗口协议及拥塞控制等功能。（面向连接的TCP协议，使得逻辑信道变为一条全双工的可靠信道）

- 多路复用数据流
  - TCP利用端口实现了同时接收多个应用数据，将多个应用的数据流的复用
- 实现可靠传输
  - 采用滑动窗口协议来实现可靠传输、超时重传
  - TCP头的校验和域可以验证TCP段的完整性
  - 采用确认应答机制保证数据段的可靠传输
- 流量控制和拥塞控制
  - 目的主机通过设置窗口大小来通知发送主机能够发送的数据量大小
  - 同时利用重发定时器实现部分拥塞控制功能

`Tips`①TCP是全双工的，点到点的，不支持组播或者广播形式 ②TCP是字节流，不保留消息边界

> **特点**

- TCP**面向连接**(虚连接)的传输层协议
- 每一条TCP连接都**只能**有 2 个端点，每个TCP连接都只能是点对点的
- TCP可靠有序、不丢不重。按序到达、无差错、不丢失、不重复
- TCP提供**全双工通信**的。在接收数据的同时可以发送数据
  - 发送缓存：准备发送的数据 & 已发送但尚未确认的数据
  - 接收缓存：按序到达但尚尚未被 应用程序 读取的数据 & 不按序到达的数据
- TCP面向字节流的
  - TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

> **TCP的报文格式**

![image-20210312110938693](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210312110938693.png)

- 序号：它表示本报文段所发送数据的第一个字节的编号。
- 确认号：它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号
- 数据偏移：数据偏移是指TCP**报文段**中的“数据”部分**起始处**，距离 TCP **数据段起始处**的字节偏移量，以4B为单位（因为可能加了可选项，首部大于20B）
- 标志位字段
  - URG：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
  - ACK：表示前面的确认号字段是否有效。TCP 规定，连接建立后，ACK 必须为 1。
  - RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
  - SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。
  - FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接
- 窗口：指的是**发送端**的**接收窗口,**即允许对方发送的数据量
- 检验和：检验首部+数据，检验时要加上12B的**伪首部**(同UDP)，第四个字段为6
- 紧急指针：只有在URG=1时，才有意义。指出本报文段中紧急数据的字节数



> **重传机制**

- 采用自适应算法，动态改变重传时间，RTTs（加权平均往返时间）------ 但此方法等太久了
- 冗余ACK，连着收到三个冗余ACK时，直接进行重传。 称为**快速重传**



---

![image-20210312142059200](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210312142059200.png)



> **流量控制**

​	TCP利用**滑动窗口**机制实现流量控制。

​	在通信过程中，**接收方**根据自己**接收缓存**的大小，动态地调整**发送方**的**发送窗口**大小。

​	发送方的发送窗口取**接收窗口**和**拥塞窗口**的最小值



> **拥塞控制**(全局性)

- **四种算法**
  - 慢开始
  - 拥塞避免
  - 快重传
  - 快恢复
- **拥塞窗口**：发送方，根据自己估算的网络拥塞程度而设置的窗口值，反应网络的当前容量

`Tips`: 慢开始和拥塞避免配合使用，快重传和快恢复配合使用

![image-20210312142712302](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210312142712302.png)

### UDP

> **概述**

​		UDP协议实现的是简单的**无连接**、**不可靠**数据报传输服务， 完成了应用进程的识别，不提供流控或拥塞管理机制。仅在IP数据报服务的基础上增加了复用和分用、差错检测功能。

- UDP是**无连接**
- UDP保留应用程序定义的报文边界，不把两个应用程 序报文组合在一起，也不把单个应用报文划分成几个部分（面向报文的，一次交付一个完整的报文）  这就需要应用程序自己控制合适的报文大小
- UDP是小的、节约资源的传输层协议。它的操作执行 比TCP快得多

> **特点**

- UDP无需建立连接 (which can add delay)， 减少开销和发送数据之前的时延
- UDP使用最大努力交付，即不保证可靠交付。（由应用层来保障）
- UDP是**面向报文**的，适合一次性传输少量数据的网络应用，(容易丢失，不适合一次性传输大量数据)。
  - 如果报文过大时: 网络层就需要分片，会降低网络层的效率
  - 如果报文过小: 会使IP数据报的首部占比太大，降低网络层效率
- UDP没有拥塞控制，UDP包可以按需要快速发送，适合很多实时应用。
- UDP首部开销小，8个字节

`Tips` :面向报文含义的**图解**

![image-20210311154331558](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210311154331558.png)

> **UDP的报文格式**

![image-20210312095319337](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210312095319337.png)

- **源端口号**：通常包含**发送端**发送数据报的应用程序所使用的 UDP 端口。可以全为0（如果不需要回信）
- **目的端口号**：**接收端**计算机上 UDP 软件使用的端口
- **UDP长度**：表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8
- **UDP检验和**：可以检验数据在传输过程中是否被损坏，若损坏则丢弃

`Tips`: 分用时，如果找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报文。



> **UDP检验和的计算过程**(UDP校验)

![image-20210312100340007](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210312100340007.png)

> **伪首部介绍**

- **伪首部**：模仿的是**IP数据报**的首部
  - 只有在计算校验和的时候出现，不会出现在传输中
  - 图中的第三个字段 ‘0’，是固定设为全0的
  - 第四个字段 ‘17’，封装IP数据报首部协议字段，代表传输层使用的协议为UDP
  - UDP长度：UDP首部+数据部分长度(不包括伪首部)

> **具体例子**

![image-20210312102149781](E:\Study\自整理\为了offer!\葱刺\计算机网络.assets\image-20210312102149781.png)

`Tips: ` 数据字段不足4字节时，用0来填充



**UDP的应用**

- 经常用于多媒体流传输（可容忍丢包、速率敏感）
- RIP（路由信息周期发送）
- DNS（避免TCP连接建立延迟）
- SNMP（当网络拥塞时，网管也要运行。网管信息带内（in-band） 传输，用UDP比用可靠的、具有拥塞控制的TCP效果要好。）
- RPC（远程过程调用）
- RTP（实时传输协议）



### TCP与UDP的区别

- TCP
  - 面向连接的传输控制协议，数据传输前需要建立连接，数据传输结束后需要释放连接
  - 不提供广播或多播服务
  - 需要确认、流量控制、计时器及连接管理来保障传输可靠性，但时延大，适用于大文件

- UDP
  - 无连接的用户数据报协议UDP
  - 不需要建立连接，也不需要对报文段给出确认，时延小，适用于小文件

