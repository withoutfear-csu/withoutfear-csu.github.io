---
layout: post
title: Redis的主从同步
categories: Redis
description: 本文主要介绍了Redis的主从同步
keywords: Redis, 主从同步
---

本⽂主要参考：[阮⼀峰的网络日志](https://www.ruanyifeng.com/blog/2018/07/cap.html)以及《Redis深度历险》



## 前置知识

​	为了使得服务可靠，Redis在运⽤中基本都会做主从，当 master 挂掉的时候，让从库来接管服务。没有 主从的话，master 需要经过数据恢复和重启的过程，这就可能会拖很⻓的时间，影响线上业务的持续服务。 在讲主从同步之前，需要先了解⼀下分布式系统理论的基⽯——「CAP」定理。 

### CAP

**CAP的三个指标** 

- C - ⼀致性 (Consistency)：即从每个区(partition)查询相同记录所返回的结果应当是⼀致的，不会有不 同的结果。 
- A - 可⽤性 (Availability)：即服务器必须及时对⽤户的请求进⾏回应。 
-  P - 分区容错 (Partition tolerance)：分布式系统的节点往往是分布在不同机器上，不同机器⼜分布在多 个⼦⽹络下形成不同的区(partition)，存在⽹络隔离。这意味着⼦⽹络之间的区间通信有可能失败。这种 情况就称为分区容错。 

> **根据CAP定理，分布式系统只能满⾜三项中的两项⽽不可能满⾜全部三项**

![](\images\posts\Redis\CAP.jpg)

​	就分布式系统而言，分区容错⼀般是无法避免的，可以认为「CAP」中的「P」总是成⽴。那么根据 「CAP」定理，剩下「C」「A」是无法同时满⾜的。 

**「C」「A」之间的⽭盾** 

​	「C」「A」是⽆法同时满⾜的答案很明显——「P」的成⽴意味着可能出现通信失败。(这种网络断开的场景 被称为**「网络分区」**)

![](\images\posts\Redis\[P].jpg)

在发⽣**「网络分区」**的时候，显然数据不能及时同步。 

- 如果要保证「C」就需要暂停那些数据尚未同步的节点的服务，这就意味着牺牲了这些节点的可⽤性，不 满⾜「A」； 
- 如果要保证「A」就应该让服务继续，那么必然不出现不同节点的数据不⼀致的情况，这意味着牺牲了⼀ 致性，不满⾜「C」。 



> **下面言归正传，来讲Redis中主从同步的具体实现。** 

### 最终⼀致性 

前⾯了解了CAP理论，那么Redis主从同步中是采⽤了何种策略？Redis的主从数据，是以异步的⽅式进⾏ 同步的，主节点向从节点传数据时，会⽴即返回，这样即使主从⽹络断开了，主节点依然可以向外提供服 务，所以满⾜了「A」。也因此，Redis系统不满⾜「C」，但却保证「最终⼀致性」，所谓「最终⼀致性」 就是指如果⽹络断开了，主从节点的数据出现了⼤量不⼀致，等到⽹络恢复从节点会采⽤多种策略努⼒补上 落后的数据，继续尽⼒保持和主节点⼀致。



## 增量同步

![](\images\posts\Redis\circle_array.png)

​	增量同步是指主节点会将那些对⾃⼰的状态产⽣修改性影响的指令，记录在本地的 buffer中(以环形数组的 结构存在)。然后以异步的⽅式将buffer中的指令同步给从节点，从节点⼀边执⾏传⼊的指令流以达到和主节 点⼀致的状态，⼀边以偏移量的形式向主节点反馈当前同步到的位置。但由于buffer循环写的特性，如果⽹ 络状况不佳，就有可能出现**错误覆盖**(没完成同步的指令被覆盖)。这时，增量同步就出错了，需要**「快照同步」**来挽救这⼀局⾯。

## 快照同步

​	**「快照同步」**首先需要拍个照(执行bgsave将当前的内存数据全部保留到磁盘⽂件中)，然后将这张快照交 给从节点。从节点拿到快照后(将接收到的内容存储在磁盘⽂件中)，立即将自己的缓存清空，按照快照执行⼀次**全量加载**。全量加载完成后，从节点需要知道它在加载的这段时间内发⽣了什么，于是他需要通知主节 点进行**增量同步**，告诉他这段时间发⽣了什么。但如果从节点全量加载的时间过长，连主节点都忘了这段时 间的细节(buffer写满后发⽣**错误覆盖**)，那就不得不重复⼀次**「快照同步」**，因此如果为buffer配置的大小不 合适，就有可能发生死循环。另外，如果要增加从节点，也会经历这样的流程。

### 无盘复制

​	**「快照同步」**时执⾏bgsave会进行很重的⽂件IO操作，特别是如果此时系统正在执⾏AOF的fsync操作， fsync就会被推迟执⾏，会严重影响主节点的服务效率。因此**「无盘复制」**就出现了，**「无盘复制」**是指主服 务器⼀边遍历内存，⼀边将序列化的内容通过套接字发送到从节点，从节点的反应和**「快照同步」**中⼀样， 相⽐于**「快照同步」**，**「无盘复制」**省略了**bgsave**的执⾏。

## Wait指令

​	为了保持Redis⾼可⽤，复制是通过异步⽅式进⾏的，但为了追求强⼀致性，就需要提供同步复制的⽅式。 **「Wait」**指令的出现就是为了探索「C」「A」之间的平衡点。 

> **即便使用了wait指令，如果主节点在同步的过程中挂掉了，数据依然会丢失，主从数据也就不一致了**

**wait指令的使用**

​	wait [num] [time] —— num: 从库的数量；time: 等待时间 

**解释说明**

​	上述指令表示的意思：需要等待wait指令前的所有写操作同步到num个从节点，最⻓等待时间为time (特别 的，0表示⽆限等待⽽不是不等待的意思)。因此，当time=0时，若发⽣了⽹络分区wait指令会使得redis永久 等待，也就丧失了可⽤性。 

**扩展**

​	 使用**「Wait」**指令不能解决数据丢失的情况，但**「Redis Sentinel(哨兵)」**的存在能减少主节点挂了的情况下数据的丢失。

