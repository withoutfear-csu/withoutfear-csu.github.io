---
layout: post
title: Redis-主从同步
categories: Redis
description: Redis的主从同步
keywords: Redis
---

本文介绍了Redis中的主从同步，主要为《Redis深度历险》的读书笔记，以及极客专栏等网络资料摘录。

# 前置知识

​	为了使得服务可靠，Redis在运用中基本都会做主从，当 master 挂掉的时候，让从库来接管服务。没有主从的话，master 需要经过数据恢复和重启的过程，这就可能会拖很长的时间，影响线上业务的持续服务。在讲主从同步之前，需要先了解一下分布式系统理论的基石——「CAP」定理。



## CAP

**CAP的三个指标**

- C - 一致性  (Consistency)：即从每个区(partition)查询**相同记录**所返回的结果应当是**一致的**，不会有不同的结果。
- A - 可用性  (Availability)：即服务器必须及时对用户的请求进行回应。
- P - 分区容错 (Partition tolerance)：分布式系统的节点往往是分布在不同机器上，不同机器又分布在多个子网络下形成不同的区(partition)，存在网络隔离。这意味着子网络之间的区间通信有可能失败。这种情况就称为分区容错。

根据CAP定理，分布式系统只能满足三项中的两项而不可能满足全部三项

![CAP](\images\posts\Redis\CAP.jpg)

​	就分布式系统而言，分区容错一般是无法避免的，可以认为「**CAP」**中的「P」总是成立。那么根据「CAP」定理，剩下「C」「A」是无法同时满足的。

**「C」「A」之间的矛盾**

「C」「A」是无法同时满足的答案很明显——「P」的成立意味着可能出现通信失败。(这种网络断开的场景被称为**「网络分区」)

![区间通信失败](\images\posts\Redis\[P].jpg)



在发生**「网络分区」**的时候，显然数据不能及时同步。

- 如果要保证「C」就需要暂停那些数据尚未同步的节点的服务，这就意味着牺牲了这些节点的可用性，不满足「A」；
- 如果要保证「A」就应该让服务继续，那么必然不出现不同节点的数据不一致的情况，这意味着牺牲了一致性，不满足「C」。

------



# 读写分离

  Redis提供了主从库的模式，主从库之间采用的是**读写分离**的方式

- **写操作**：在主库上处理，再同步到从库；
- **读操作**：主库、从库都可以处理。

​	如果从库也可以处理写操作，那么考虑这么一种情况：客户端对同一个数据(例如key) 前后修改了三次，每一次的修改请求都发送到不同的实例上，在不同的实例上执行。那么，这个数据在这三个实例上的副本就不一致了(分别是v1、v2和v3)，这时为了实现一致性，就需要涉及加锁、实例间协商等一系列操作，造成巨额开销。



# 最终一致性

​	前面了解了CAP理论，那么Redis主从同步中是采用了何种策略？Redis的主从数据，是以异步的方式进行同步的，主节点向从节点传数据时，会立即返回，这样即使主从网络断开了，主节点依然可以向外提供服务，所以满足了「A」。也因此，Redis系统不满足「C」，但却保证「最终一致性」，所谓「最终一致性」就是指如果网络断开了，主从节点的数据出现了大量不一致，等到网络恢复从节点会采用多种策略努力补上落后的数据，继续尽力保持和主节点一致。



# 主从复制的两个阶段

> **快照同步保存的是数据，增量同步保存的是Redis指令**

## 快照同步

​	「**快照同步」**首先需要拍个照(执行**bgsave**将当前的**内存数据**全部保留到磁盘文件中)，然后将这张快照交给从节点。从节点拿到快照后(将接收到的内容存储在磁盘文件中)，立即将自己的缓存清空，按照快照执行一次**全量加载**。

### 无盘复制

​	**「快照同步」**时执行**bgsave**会进行很重的文件IO操作，特别是如果此时系统正在执行AOF的fsync操作，fsync就会被推迟执行，会严重影响主节点的服务效率。因此**「无盘复制」**就出现了，**「无盘复制」**是指主服务器一边遍历内存，一边将序列化的内容通过套接字发送到从节点，从节点的反应和**「快照同步」**中一样，相比于「快照同步」，「无盘复制」省略了**bgsave**的执行。



## 增量同步

​	由于主节点在「**快照同步**」的这段未中断服务，因此从节点全量加载完成后，需要知道主节点这段时间的变化，于是需要通知主节点进行「**增量同步」**。

### replication buffer

​	在专栏及一些博客中强调了**replication buffer**这一概念，其实Redis和客户端通信也好，和从库通信也好，Redis都会分配一个内存buffer用于数据交互：Redis先将数据写入buffer，再发到client socket后通过网络传输出去，以完成数据交互。只不过这个buffer专门用来传输写命令到从库来保证主从数据一致，我们才通常将它称为**replication buffer**。

**buffer大小的限制**

​	Redis中提供了client-output-buffer-limit参数来限制buffer的大小，防止从库来不及处理时挤压过多命令消耗大量内存资源。当buffer中积压的数据大小超过限制后，主库就会断开这个client的连接。中断后，主从间需要重新执行复制的过程，因此大小设置不当可能会产生恶性循环引发复制风暴。

**网络连接断开的影响**

​	在从节点加载完快照后，replication buffer里面主要记录了以下时间段所产生的指令：

- 主节点执行 **bgsave** 生成 **rdb** 文件的时间段；
- 主节点将 **rdb** 文件传输给从节点所需的网络传输的时间段；
- 从节点加载 **rdb** 文件到内存的时间段

​	**replication buffer** 在连接断开时，会被释放。因此出现网络闪断，就会使得上述时间段内生成的数据丢失，不得不重来一次「**快照同步**」，这未免开销太大。引入**replication backlog buffer**可以有效解决这一问题。

### replication backlog buffer

​	**replication backlog buffer**是一个环形缓冲，只要有从库存在，这个缓冲区就会存在。主库将所有写指令传输给从库的同时，也会以循环写的方式记录在**replication backlog buffer** 中。

​	当网络连接断开，从库在重连的时候，会以偏移量 **$offset** 的形式向主节点反馈当前同步到的位置，主库只需要通过 **$offset** 找到从库同步到的位置，发送 $offset 之后的增量数据给从库。

**注意**：但由于buffer循环写的特性，如果网络状况不佳，断开时间过长，就有可能出现**错误覆盖**(没完成同步的指令被覆盖)。这时，就需要**「快照同步」**来挽救这一局面。如果为buffer配置的大小不合适，就有可能发生死循环。

![image-20210825173626735](\images\posts\Redis\circle_array.png)

​	当网络连接断开，从库在重连的时候，会以偏移量 **$offset** 的形式向主节点反馈当前同步到的位置，主库只需要通过 **$offset** 找到从库同步到的位置，发送 $offset 之后的增量数据给从库。

**注意**：但由于buffer循环写的特性，如果网络状况不佳，断开时间过长，就有可能出现**错误覆盖**(没完成同步的指令被覆盖)。这时，就需要**「快照同步」**来挽救这一局面。如果为buffer配置的大小不合适，就有可能发生死循环。



## 一次完整的主从复制

**psync**指令携带的两个参数

- **runID**: runID，是每个Redis实例启动时都会自动生成的一个随机ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以将runID设为“？”
- **offset**: 用于连接断开后，请求连接重连时以偏移量的方式告知主库当前从库同步到的位置。当从库和主库第一次复制时，设置为-1

**FULLRESYNC**: 表示采用的是全量复制

![一次完整复制](\images\posts\Redis\一次完整复制.jpg)

**注意**：当从库过多的时候，主库可能会忙于**fork**子进程来生成RDB文件，这会阻塞主进程处理请求。可以使用**“主-从-从”**这种主从级联模式来减轻主库的压力。



# Wait指令

​	为了保持Redis高可用，复制是通过异步方式进行的，但为了追求强一致性，就需要提供同步复制的方式。**「Wait」**指令的出现就是为了探索「C」「A」之间的平衡点。

**wait指令的使用**

​	wait [num] [time] —— num: 从库的数量；time: 等待时间

**解释说明**

​	上述指令表示的意思：需要等待wait指令前的所有写操作同步到num个从节点，最长等待时间为time (特别的，0表示**无限等待**而不是不等待的意思)。因此，当time=0时，若发生了网络分区wait指令会使得redis永久等待，也就丧失了可用性。

**拓展**

​	使用「Redis Sentinel(哨兵)」一样可以减少主节点挂了之后的数据丢失。

  

# 参考文献

**书籍**

- **《Redis深度历险》**

**极客专栏**

- 06 | 数据同步：主从库如何实现数据一致

**博客**

- [阮一峰的网络日志](https://www.ruanyifeng.com/blog/2018/07/cap.html)
- [DBA的卢浮宫-redis主从复制](http://mdba.cn/2015/03/17/redis主从复制（2）-replication-buffer与replication-backlog/)